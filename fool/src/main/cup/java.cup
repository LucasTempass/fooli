import java_cup.runtime.*;

terminal CLASS;
terminal SEMICOLON, COMMA, LBRACE, RBRACE, EQ, LPAREN, RPAREN;
terminal BOOLEAN;
terminal INT;
terminal VOID;
terminal IF, ELSE;
terminal RETURN;
terminal PLUS, MULT;
terminal AND, OR, NOT;
terminal EQEQ, NOTEQ;

terminal java.lang.Integer INTEGER_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.String IDENTIFIER;

non terminal goal;
// 19.3) Lexical Structure
non terminal literal;
// 19.4) Types, Values, and Variables
non terminal type, primitive_type, numeric_type;
non terminal integral_type, floating_point_type;
non terminal reference_type;
non terminal class_or_interface_type;
non terminal class_type, interface_type;
non terminal array_type;
// 19.5) Names
non terminal name, simple_name, qualified_name;
// 19.6) Packages
non terminal compilation_unit;
non terminal package_declaration_opt, package_declaration;
non terminal import_declarations_opt, import_declarations;
non terminal type_declarations_opt, type_declarations;
non terminal import_declaration;
non terminal single_type_import_declaration;
non terminal type_import_on_demand_declaration;
non terminal type_declaration;
// 19.7) Productions used only in the LALR(1) grammar
non terminal modifiers_opt, modifiers, modifier;
// 19.8.1) Class Declaration
non terminal class_declaration, super_cl, super_opt;
non terminal interfaces, interfaces_opt, interface_type_list;
non terminal class_body;
non terminal class_body_declarations, class_body_declarations_opt;
non terminal class_body_declaration, class_member_declaration;
// 19.8.2) Field Declarations
non terminal field_declaration, variable_declarators, variable_declarator;
non terminal variable_declarator_id, variable_initializer;
// 19.8.3) Method Declarations
non terminal method_declaration, method_header, method_declarator;
non terminal formal_parameter_list_opt, formal_parameter_list;
non terminal formal_parameter;
non terminal throws_opt, throws;
non terminal class_type_list, method_body;
// 19.8.4) Static Initializers
non terminal static_initializer;
// 19.8.5) Constructor Declarations
non terminal constructor_declaration, constructor_declarator;
non terminal constructor_body;
non terminal explicit_constructor_invocation;
// 19.9.1) Interface Declarations
non terminal interface_declaration;
non terminal extends_interfaces_opt, extends_interfaces;
non terminal interface_body;
non terminal interface_member_declarations_opt, interface_member_declarations;
non terminal interface_member_declaration, constant_declaration;
non terminal abstract_method_declaration;
// 19.10) Arrays
non terminal array_initializer;
non terminal variable_initializers;
// 19.11) Blocks and Statements
non terminal block;
non terminal block_statements_opt, block_statements, block_statement;
non terminal local_variable_declaration_statement, local_variable_declaration;
non terminal statement, statement_no_short_if;
non terminal statement_without_trailing_substatement;
non terminal empty_statement;
non terminal labeled_statement, labeled_statement_no_short_if;
non terminal expression_statement, statement_expression;
non terminal if_then_statement;
non terminal if_then_else_statement, if_then_else_statement_no_short_if;
non terminal switch_statement, switch_block;
non terminal switch_block_statement_groups;
non terminal switch_block_statement_group;
non terminal switch_labels, switch_label;
non terminal while_statement, while_statement_no_short_if;
non terminal do_statement;
non terminal for_statement, for_statement_no_short_if;
non terminal for_init_opt, for_init;
non terminal for_update_opt, for_update;
non terminal statement_expression_list;
non terminal identifier_opt;
non terminal break_statement, continue_statement;
non terminal return_statement, throw_statement;
non terminal synchronized_statement, try_statement;
non terminal catches_opt, catches, catch_clause;
non terminal finally;
// 19.12) Expressions
non terminal primary, primary_no_new_array;
non terminal class_instance_creation_expression;
non terminal argument_list_opt, argument_list;
non terminal array_creation_expression;
non terminal dim_exprs, dim_expr, dims_opt, dims;
non terminal field_access, method_invocation, array_access;
non terminal postfix_expression;
non terminal postincrement_expression, postdecrement_expression;
non terminal unary_expression, unary_expression_not_plus_minus;
non terminal preincrement_expression, predecrement_expression;
non terminal cast_expression;
non terminal multiplicative_expression, additive_expression;
non terminal shift_expression, relational_expression, equality_expression;
non terminal and_expression, exclusive_or_expression, inclusive_or_expression;
non terminal conditional_and_expression, conditional_or_expression;
non terminal conditional_expression, assignment_expression;
non terminal assignment;
non terminal left_hand_side;
non terminal assignment_operator;
non terminal expression_opt, expression;
non terminal constant_expression;

start with goal;

goal ::= compilation_unit;

literal ::=	INTEGER_LITERAL | BOOLEAN_LITERAL;

primitive_type ::= INT | BOOLEAN;

compilation_unit ::= type_declarations_opt;

type_declarations_opt ::= type_declarations | ;

type_declarations ::= type_declaration | type_declarations type_declaration;

type_declaration ::= class_declaration | SEMICOLON;

class_declaration ::= CLASS IDENTIFIER class_body;

class_body ::= LBRACE class_body_declarations_opt RBRACE;

class_body_declarations_opt ::= | class_body_declarations;

class_body_declarations ::= class_body_declaration | class_body_declarations class_body_declaration;

class_body_declaration ::= field_declaration | method_declaration;

field_declaration ::= primitive_type variable_declarator SEMICOLON;

variable_declarator ::= IDENTIFIER EQ expression;

method_declaration ::= method_header block;

method_header ::= primitive_type method_declarator | VOID method_declarator;

method_declarator ::= IDENTIFIER LPAREN formal_parameter_list_opt RPAREN;

formal_parameter_list_opt ::= |	formal_parameter_list;

formal_parameter_list ::= formal_parameter | formal_parameter_list COMMA formal_parameter;

formal_parameter ::= primitive_type IDENTIFIER;

block ::= LBRACE block_statements_opt RBRACE;

block_statements_opt ::= | block_statements;

block_statements ::= statement | block_statements statement;

statement ::=	statement_without_trailing_substatement | if_then_statement | if_then_else_statement;

statement_no_short_if ::= statement_without_trailing_substatement |	if_then_else_statement_no_short_if;

statement_without_trailing_substatement ::= block |	SEMICOLON |	expression_statement | return_statement;

expression_statement ::= statement_expression SEMICOLON;

statement_expression ::= assignment | method_invocation;

if_then_statement ::= IF LPAREN expression RPAREN statement;

if_then_else_statement ::= IF LPAREN expression RPAREN statement_no_short_if ELSE statement;

if_then_else_statement_no_short_if ::= IF LPAREN expression RPAREN statement_no_short_if ELSE statement_no_short_if;

statement_expression_list ::= statement_expression | statement_expression_list COMMA statement_expression;

identifier_opt ::= | IDENTIFIER;

return_statement ::= RETURN expression_opt SEMICOLON;

primary ::= literal | LPAREN expression RPAREN | method_invocation;

argument_list ::= expression | argument_list COMMA expression;

argument_list_opt ::= |	argument_list;

method_invocation ::= IDENTIFIER LPAREN argument_list_opt RPAREN;

postfix_expression ::= primary | IDENTIFIER;

// TODO opt?
unary_expression ::= | postfix_expression;

multiplicative_expression ::= unary_expression | multiplicative_expression MULT unary_expression;

additive_expression ::= multiplicative_expression |	additive_expression PLUS multiplicative_expression;

equality_expression ::= relational_expression |	equality_expression EQEQ relational_expression | equality_expression NOTEQ relational_expression;

and_expression ::= equality_expression | and_expression AND equality_expression;

expression ::= and_expression | expression OR and_expression;

expression_opt ::= | expression;

assignment ::=	IDENTIFIER EQ expression;


